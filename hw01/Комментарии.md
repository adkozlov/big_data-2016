## Алгоритмы решений

Решения условно назывались "квадратичными" и "линейными". Квадратичные решения
для каждого ключа читали содержащий его файл (обычно с самого начала), линейные
читали каждый файл не более одного раза.

Основное линейное решение заключается в группировке ключей по шардам с использованием записей о диапазонах и последующем чтении
каждого шарда с ключами и суммировании сразу всех значений ключей. Группировку можно
делать при помощи, например, словаря (dict), хотя возможен (но никем не реализован)
алгоритм, не использующий словарь. Нужно отсортировать ключи и диапазоны и, итерируясь по диапазонам, смотреть, содержит ли очередной диапазон очередной ключ и последующие за ним. Если содержит, то читать шард с начала или, если мы его ранее уже читали, то с сохраненного места. Благодаря отсортированности мы прочитаем списки диапазонов и ключей 1 раз, и благодаря условиям на содержимое шардов каждый шард и каждый фрагмент тоже прочитаем не более 1 раза.

## Оценки

Квадратичные решения обычно получали оценку "2",
линейные обычно получали оценку "4".

В основном на оценку влияли перечисленные ниже стандартные ошибки (в них же входит и
  квадратичное решение). Дополнительные проверки валидности данных могли оценку улучшить,
  дополнительные нестандартные ошибки могли её ухудшить.

Решения, не запускавшиеся без специальных пинков, или дававшие неправильный ответ, обычно получали оценку 1.

## Стандартные ошибки

В абсолютном большинстве рецензий есть пункт "стандартные ошибки", являющийся подмножеством
из следующего множества ошибок:

1. **get_file_content делает что-то отличное от возврата итератора по фрагментам  файла с DFS.**
   В задании недвусмысленно требовалось: _функция принимает имя файла и
   возвращает итератор по его строкам._ Ошибка могла снизить оценку на 1 балл
1. **в get_file_content chunk_locations вызывается много раз**.
   Эта ошибка оказалась нестандартной :)
1. **для каждого ключа вызывается get_file_contents и файл читается с самого начала**
   Основная ошибка, приводящая к многократному чтению одного и того же файла и "квадратичному"
   алгоритму. Решения с такой ошибкой не получали больше 2 баллов
1. **файл читается до конца, даже если ключей в нем больше не предвидится**
   Если нас интересовал один ключ, находившийся в самом начале файла, то оставшиеся фрагменты,
   очевидно читать не нужно. При линейном алгоритме это оптимизация, но довольно существенная.
   Ошибка могла снизить оценку на 1 балл
1. **предположения о /keys или /partitions: отсортированы, состоят из одного фрагмента**
1. **предположения о данных: отсортированность, 1 фрагмент=1диапазон**
   То, что тестовые данные обладают какими-то удобными свойствами, не означает, что так будет всегда. Все свойства отсортированности были явно перечислены в задании, надежды на какие-то
   дополнительные были ложными. Ошибка могла снизить оценку на 1 балл
